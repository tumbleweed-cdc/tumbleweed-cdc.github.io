<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-problem_domain" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.3">
<title data-rh="true">Problem Domain | Tumbleweed</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://tumbleweed-cdc.github.io/img/FaviconTumbleweedTransparent.ico"><meta data-rh="true" name="twitter:image" content="https://tumbleweed-cdc.github.io/img/FaviconTumbleweedTransparent.ico"><meta data-rh="true" property="og:url" content="https://tumbleweed-cdc.github.io/docs/problem_domain"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Problem Domain | Tumbleweed"><meta data-rh="true" name="description" content="2.1 Microservices and Event Driven Architecture"><meta data-rh="true" property="og:description" content="2.1 Microservices and Event Driven Architecture"><link data-rh="true" rel="icon" href="/img/tumbleweed_favicon.ico"><link data-rh="true" rel="canonical" href="https://tumbleweed-cdc.github.io/docs/problem_domain"><link data-rh="true" rel="alternate" href="https://tumbleweed-cdc.github.io/docs/problem_domain" hreflang="en"><link data-rh="true" rel="alternate" href="https://tumbleweed-cdc.github.io/docs/problem_domain" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a314c9aa.css">
<script src="/assets/js/runtime~main.efcb6062.js" defer="defer"></script>
<script src="/assets/js/main.3560159d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/FaviconTumbleweedTransparent.ico" alt="Tumbleweed Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/FaviconTumbleweedTransparent.ico" alt="Tumbleweed Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Tumbleweed</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/introduction">Case Study</a><a class="navbar__item navbar__link" href="/#team">Team</a><a href="https://github.com/tumbleweed-cdc" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/problem_domain">Problem Domain</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/existing_solutions">Existing Solutions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/tumbleweed">Tumbleweed</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/using_tumbleweed">Using Tumbleweed</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/challenges">Challenges</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/future_work">Future Work</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Problem Domain</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>2. Problem Domain</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-microservices-and-event-driven-architecture">2.1 Microservices and Event Driven Architecture<a href="#21-microservices-and-event-driven-architecture" class="hash-link" aria-label="Direct link to 2.1 Microservices and Event Driven Architecture" title="Direct link to 2.1 Microservices and Event Driven Architecture">​</a></h2>
<p>Microservice architectures have become a prominent solution to the difficulties involved in maintaining and scaling large-scale applications. Whereas monolithic architecture functionality is built into a single unit of tightly-coupled components, a microservice architecture separates core functionality into smaller, independent services. These services are typically distributed across a network. This allows for each service to be maintained and scaled independently as needed, which in turn allows for faster development cycles.</p>
<p>The flexibility and scalability of a distributed architecture introduces additional challenges, particularly in the realm of inter-service communication and data exchange. A good microservice architecture involves the decoupling of services from each other. In other words, services should be as autonomous as possible, with few external dependencies.<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> It is precisely this autonomy and loose coupling between services that provides much of the benefit of microservice architectures: allowing for services to fail and/or change in isolation, scale as needed, and more.</p>
<p>Perhaps the greatest challenge<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup> then becomes how to exchange data between services under famously unreliable and complex circumstances<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>, while maintaining this autonomy and decoupling. Services that need to interact are required to update both their own data and propagate this data and/or send notification of the data changes to other services. While this can be done via some manner of synchronous point-to-point API (ex. REST, RPC) between services, such an approach would require the services to be aware of each other to a degree that creates more coupling than is ideal in microservice architectures. Such tight coupling can lead to issues in a variety of ways, such as when a service becomes unavailable, when implementing new services, or when refactoring existing services.<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup> Additionally, if data is propagated in a synchronous manner, this can become a blocking bottleneck with cascading effects throughout the system.</p>
<p>One solution for this problem is the use of Event Driven Architecture (EDA). In EDA, any “state changes” in a service can also be viewed as events, and records of such events can be sent as messages to be consumed by other services.<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="true" aria-describedby="footnote-label">5</a></sup> Services that need to communicate assume the role of event producers and/or event consumers. We can further enhance the strong decoupling of this approach by introducing an event stream processing platform to receive data from producers and propagate them to downstream consumers.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-event-stream-processing-and-message-brokers">2.2 Event Stream Processing and Message Brokers<a href="#22-event-stream-processing-and-message-brokers" class="hash-link" aria-label="Direct link to 2.2 Event Stream Processing and Message Brokers" title="Direct link to 2.2 Event Stream Processing and Message Brokers">​</a></h2>
<p>In event stream processing, an event is a record or &quot;...a small, self-contained, immutable object containing the details of something that happened at some point in time...&quot;<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup> and an event stream is therefore an &quot;unbounded, incrementally processed<sup><a href="#user-content-fn-6" id="user-content-fnref-6-2" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup> &quot; stream of such data. Many event stream processing frameworks can also be described as asynchronous message-passing systems or message brokers.<sup><a href="#user-content-fn-6" id="user-content-fnref-6-3" data-footnote-ref="true" aria-describedby="footnote-label">6</a></sup> Generally speaking, message brokers allow producing processes to send messages or records to a topic or queue, then the broker facilitates the delivery of that data to subscribed consumers.</p>
<p><img decoding="async" loading="lazy" alt="Event Streaming" src="/assets/images/event_streaming-0416233c574db584b036c9219cc59bbf.svg" title="Event streaming" width="1800" height="501" class="img_ev3q">
</p><figcaption>Figure 2: Event Stream Processing.</figcaption><p></p>
<p>The use of a message broker has a number of advantages over direct messaging between services. It can act as a buffer for when consumers are unavailable and more easily allows for a single message to be sent to multiple consumers. This approach also promotes greater decoupling between producer and consumer services, allowing microservices to be designed agnostic as to whom the event data is being sent or how it is being consumed. <sup><a href="#user-content-fn-7" id="user-content-fnref-7" data-footnote-ref="true" aria-describedby="footnote-label">7</a></sup> Consumers,  likewise, subscribe to only the types of events that concern their business logic and receive these events for processing from the streaming platform.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-the-dual-write-problem">2.3 The Dual-Write Problem<a href="#23-the-dual-write-problem" class="hash-link" aria-label="Direct link to 2.3 The Dual-Write Problem" title="Direct link to 2.3 The Dual-Write Problem">​</a></h2>
<p>As we’ve seen, a microservice architecture introduces many challenges related to data management across services and one of the most notable is the dual-write problem.
A dual-write may occur when data needs to be written to different systems. For example, if one service has its own database and needs to propagate information to other services, the data is typically written to the source database as well as another system, such as a message broker, before reaching its destination.</p>
<p>This process of writing changes to separate systems is where problems can arise and create data inconsistencies between services. If the data successfully writes to the source database but fails to be sent to a message broker due to some kind of application or network issue, the source database will have a record of the change even if the destination never receives it.</p>
<p><img decoding="async" loading="lazy" alt="Dual Write 1" src="/assets/images/dual-write_1-d26c82253f357eb731c0a3e15bf64a34.svg" title="Dual Write Problem 1" width="1600" height="801" class="img_ev3q">
</p><figcaption>Figure 1: Fails to write to the message broker.</figcaption><p></p>
<p>On the other hand, if the data was successfully written to a message broker, but failed to write to the source database, the destination service received the message but the source database has no record of it. Either scenario can result in errors or data inconsistencies, complicating operations between services.</p>
<p><img decoding="async" loading="lazy" alt="Dual Write 2" src="/assets/images/dual-write_2-b2cdef87941337a3f5364ef3f0a2380e.svg" title="Dual Write Problem 2" width="1600" height="801" class="img_ev3q">
</p><figcaption>Figure 2: Fails to write to the source database.</figcaption><p></p>
<p>One solution is to only write changes once. If we chose to write changes to a broker, the source service would be listening for new messages, as well as the destination service. When a change occurs in the source service, the message is first sent to the broker before being consumed by both the source and destination services.</p>
<p>This scenario comes with its own drawbacks. While data may eventually be consistent, a source service writing to the broker before updating its own database can introduce latency and create delays, especially if that data needs to be immediately queried from the source database. This has the potential to negatively impact user experience. The handling of delivery failures would also need to be considered. For example, if a message was successfully sent to the message broker but failed to write to the source database for some reason, additional retry logic may be required to address this failure.</p>
<p>Instead, we could write changes to the source database before pushing messages to a broker. For such an approach, a microservice architecture design pattern known as the “transactional outbox pattern” can be used.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-the-outbox-pattern">2.4 The Outbox Pattern<a href="#24-the-outbox-pattern" class="hash-link" aria-label="Direct link to 2.4 The Outbox Pattern" title="Direct link to 2.4 The Outbox Pattern">​</a></h2>
<p>When using the transactional outbox pattern, database changes are recorded locally to a specially created “outbox” table within the same transaction as the original operation. Transactions in a database allow multiple actions to be carried out as a single logical operation. The outbox table stores metadata about the changes, such as the operation type, and a data payload. Separate processes should then monitor the outbox table for new entries and update the necessary microservices accordingly.</p>
<p><img decoding="async" loading="lazy" alt="Outbox Pattern" src="/assets/images/outbox_pattern-c554b303ac13aead90fb991c60da5f22.svg" title="Outbox Pattern" width="1800" height="1006" class="img_ev3q">
</p><figcaption>Figure 3: The outbox pattern.</figcaption><p></p>
<p>Outbox table schemas can vary but typically include the following columns:</p>
<ul>
<li><code>id</code>: A unique identifier for each outbox event</li>
<li><code>aggregatetype</code>: An event descriptor, often called a topic, which can be used for categorized routing of event records via a messaging system. For example, In an order propagating service, a change to an orders database might have the aggregate type of “orders”.</li>
<li><code>type</code>: An event category sub-type, e.g. “order_created” which can be used by an event stream processing framework and/or consumer microservices for filtering purposes or triggering various actions.</li>
<li><code>payload</code>: A JSONB object that contains the actual data of the event, e.g. the row-level data change to the orders database.</li>
<li><code>aggregateid</code>: An event key which is the ID of the payload and is used for correct ordering of event records in a messaging system.</li>
</ul>
<p>Though the outbox pattern is an effective solution to the dual-write problem, it also comes with its own potential drawbacks. Source services now have to write additional statements to insert data to an outbox table, which could have an impact on latency and throughput. In most situations, this likely wouldn’t be noticeable, but may be something to consider if your application is processing large volumes of data. There is also a risk of losing messages or accumulating excess data if the outbox table is not properly managed.</p>
<p>While the outbox pattern can be configured in multiple ways, implementing it via Change Data Capture can ensure that all changes to the source database are efficiently propagated to other microservices in near real-time.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="25-change-data-capture">2.5 Change Data Capture<a href="#25-change-data-capture" class="hash-link" aria-label="Direct link to 2.5 Change Data Capture" title="Direct link to 2.5 Change Data Capture">​</a></h2>
<p>Data has become a fundamental component of our world and when it comes to choosing the best way to manage and move that data, there are two common methods, Extract, Transform, Load (ETL) and Change Data Capture (CDC). ETL is a more traditional approach and most effective when data can be moved in larger batches (batch processing) at regular intervals. CDC is best used in streaming data contexts, where batching makes less sense, and information is needed in near real-time. Near real-time refers to systems that can tolerate slightly longer than the 250 milliseconds required for hard real-time. As many modern data systems involve a non-stop flow of data, CDC is taking prominence as a valuable approach.</p>
<p>Change Data Capture (CDC) is the process of monitoring a source, capturing data changes in near real-time, and propagating those changes to a variety of downstream consumers, which may include other databases, caches, applications, and more. There are three primary CDC methods in common usage: time-based, trigger-based, and log-based.
Time-based CDC requires semi-invasive database schema changes by adding timestamp columns to each table that tracks when the row was last modified. While somewhat straightforward to implement, time-based CDC is unable to track delete operations and every row in a table must be scanned to find the latest updated value, making it suitable only when a small percentage of data changes.</p>
<p><img decoding="async" loading="lazy" alt="Time Based CDC" src="/assets/images/timestamp-based_CDC-ceb49d01b144dd931f925bb8f725e250.svg" title="Timestamp Based CDC" width="1301" height="401" class="img_ev3q">
</p><figcaption>Figure 4: Time-Based CDC</figcaption><p></p>
<p>Trigger-based CDC involves using a built-in database function that is automatically triggered whenever an insert, update, or delete operation occurs on a table. These changes are then stored in what is often called a “shadow table”, which can then be used for propagation of data changes to downstream systems. While triggers are supported by most databases, this method requires multiple writes for every change which impacts the source database performance. It can also become cumbersome to manage a large number of triggers.</p>
<p><img decoding="async" loading="lazy" alt="Trigger Based CDC" src="/assets/images/Trigger-based_CDC-c24b2d4d9285e7c0b9335b2ee8da54d6.png" title="Trigger Based CDC" width="1301" height="401" class="img_ev3q">
</p><figcaption>Figure 4: Trigger-Based CDC</figcaption><p></p>
<p>Although both time-based and trigger-based CDC still remain in use, log-based CDC has emerged as a generally more efficient and less invasive technique by capturing changes directly from database transaction logs.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="251-log-based-cdc">2.5.1 Log-based CDC<a href="#251-log-based-cdc" class="hash-link" aria-label="Direct link to 2.5.1 Log-based CDC" title="Direct link to 2.5.1 Log-based CDC">​</a></h3>
<p><img decoding="async" loading="lazy" alt="Log Based CDC" src="/assets/images/log-based-cdc-76e18054de9f8fb2474eba75f498cdcd.png" width="1103" height="481" class="img_ev3q">
</p><figcaption>Figure 5: Log-Based CDC</figcaption><p></p>
<p>For applications that need to access data in near-real time, Log-based CDC is the most widely-used among the various CDC solutions.  When changes happen to a database via create, update, or delete operations, the database writes these changes into the transaction log before they are written to the database. In PostgreSQL the transaction log is known as the Write-Ahead Log (WAL). The primary use for transaction logs is backup and recovery, but various CDC tools can read from these logs in order to replicate changes and send them to other systems.</p>
<p>Some of the advantages of log-based CDC include:</p>
<ul>
<li>Near real-time tracking of changes, ensuring quick delivery to target systems.</li>
<li>Minimal performance impact on source database since changes are read from transaction logs instead of the direct database querying method that other techniques may use.</li>
<li>Changes are received in the same order that they occurred, ensuring data consistency.</li>
</ul>
<p>One of the disadvantages of Log-based CDC is that it is highly dependent on the type of source database being used. No universal log format or mechanisms between different types of databases results in less flexibility in CDC solutions. For example, Tumbleweed only works with PostgreSQL and would require significant modification in order to accommodate other database types.</p>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_LWe7 sr-only" id="footnote-label">Footnotes<a href="#footnote-label" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">​</a></h2>
<ol>
<li id="user-content-fn-1">
<p><a href="https://blog.christianposta.com/microservices/why-microservices-should-be-event-driven-autonomy-vs-authority/" target="_blank" rel="noopener noreferrer">C. Posta, “Why Microservices Should Be Event Driven: Autonomy vs Authority,” Software Blog, May 27, 2016</a>. <a href="#user-content-fnref-1" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-2">
<p><a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/" target="_blank" rel="noopener noreferrer">C. Posta, “The hardest part about microservices: your data,” Software Blog, Jul. 14, 2016.</a> <a href="#user-content-fnref-2" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-3">
<p><a href="https://ably.com/blog/8-fallacies-of-distributed-computing" target="_blank" rel="noopener noreferrer">A. Diaconu, “Navigating the 8 fallacies of distributed computing,” Ably Realtime, Oct. 07, 2022.</a> <a href="#user-content-fnref-3" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-4">
<p><a href="https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/" target="_blank" rel="noopener noreferrer">G. Morling, “Reliable microservices data exchange with the outbox pattern,” Debezium, Feb. 19, 2019.</a> <a href="#user-content-fnref-4" data-footnote-backref="" aria-label="Back to reference 4" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-5">
<p><a href="https://dzone.com/articles/best-practices-for-event-driven-microservice-archi" target="_blank" rel="noopener noreferrer">J. Skowronski, “Best Practices for Event-Driven Microservice Architecture,” dzone.com, Sep. 11, 2019.</a> <a href="#user-content-fnref-5" data-footnote-backref="" aria-label="Back to reference 5" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-6">
<p>M. Kleppmann, Designing data-intensive applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems. Oreilly &amp; Associates Incorporated, 2017. <a href="#user-content-fnref-6" data-footnote-backref="" aria-label="Back to reference 6" class="data-footnote-backref">↩</a> <a href="#user-content-fnref-6-2" data-footnote-backref="" aria-label="Back to reference 6-2" class="data-footnote-backref">↩<sup>2</sup></a> <a href="#user-content-fnref-6-3" data-footnote-backref="" aria-label="Back to reference 6-3" class="data-footnote-backref">↩<sup>3</sup></a></p>
</li>
<li id="user-content-fn-7">
<p><a href="https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture" target="_blank" rel="noopener noreferrer">“What is event-driven architecture?,” redhat.com, Sep. 27, 2019.</a> <a href="#user-content-fnref-7" data-footnote-backref="" aria-label="Back to reference 7" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/introduction"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Introduction</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/existing_solutions"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Existing Solutions</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#21-microservices-and-event-driven-architecture" class="table-of-contents__link toc-highlight">2.1 Microservices and Event Driven Architecture</a></li><li><a href="#22-event-stream-processing-and-message-brokers" class="table-of-contents__link toc-highlight">2.2 Event Stream Processing and Message Brokers</a></li><li><a href="#23-the-dual-write-problem" class="table-of-contents__link toc-highlight">2.3 The Dual-Write Problem</a></li><li><a href="#24-the-outbox-pattern" class="table-of-contents__link toc-highlight">2.4 The Outbox Pattern</a></li><li><a href="#25-change-data-capture" class="table-of-contents__link toc-highlight">2.5 Change Data Capture</a><ul><li><a href="#251-log-based-cdc" class="table-of-contents__link toc-highlight">2.5.1 Log-based CDC</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>